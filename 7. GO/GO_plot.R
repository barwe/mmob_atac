## Function definition ##
suppressMessages({

    ## Load a series of Go csv files and filter term based on preset p-value
    load_go_files = function(dir, name.reg.pattern=NULL, pv.max=0.05){
        library(stringr)
        if(str_count(name.reg.pattern, "\\(.*?\\)")==0)
            stop(paste("The argument `name.reg.pattern` should contains a pair of parentheses '()'",
                       "which marks the cluster index embeded in file path."))
        
        index2str = function(x, fill='0', width=2){
            if(nchar(x) < width) 
                x = paste0(paste(rep(fill,width-nchar(x)),collapse=''),x)
            return(x)
        }
        
        if(is.null(name.reg.pattern)) name.reg.pattern = '(.*)'
        file.names = list.files(dir)
        file.paths = paste0(dir, '/', file.names)
        keys = str_match(file.names, name.reg.pattern)[,2]
        keys = sapply(keys, index2str)
        message(paste('[INFO] Set threshold of p.adjust is', pv.max))
        go_dfs = `names<-`(lapply(file.paths, function(fp){
            df = read.csv(fp, stringsAsFactors = FALSE)
            p.adjust = df[,str_ends(colnames(df), 'p.adjust')]
            df = df[p.adjust <= 0.05,]
            message(sprintf("[INFO] Load %s, total %s peaks", fp, nrow(df)))
            return(df)
        }), keys)
        go_dfs = go_dfs[order(as.numeric(names(go_dfs)))]
        nums = data.frame(t(sapply(go_dfs, dim)), stringsAsFactors = F)[[1]]
        message("[INFO] Filter out units with zero entry...")
        message(paste("       |-- Total", length(which(nums==0)), "rows"))
        go_dfs = go_dfs[nums > 0]
        
        return(go_dfs)
    }
    
    ## Combine several GO tables into one dataframe
    merge2godf = function(go.dfs, merge.field='Cluster'){
        go_dfs = lapply(names(go.dfs), function(name){
            df = go.dfs[[name]]
            old.colnames = colnames(df)
            df[[merge.field]] = rep(name, nrow(df))
            df = df[, c(merge.field, old.colnames)]
            return(df)
        })
        Reduce(rbind, go_dfs)
    }
    
    ## Make dataframe for ggplot based on a combined GO table 
    ## integrated from a set of GO result files using load_go_files
    make_ggdf = function(godf, cinfo, include=NULL, exclude=NULL, include_mode='reg', exclude_mode='reg'){
        #godf: A combined GO dataframe generated by `merge2godf` function
        #cinfo: Cluster information table, see file `each_cluster_information.rds`
        #include: Key words included in GO term
        #exclude: Key words excluded from GO term
        #include_mode: Including mode, can be set to 'reg' or 'fixed'
        #exclude_mode: Excluding mode, can be set to 'reg' or 'fixed'
        library(stringr)
        #Query index from godf according to key words and match type
        query_idx = function(kws, mode, godf=godf){
            if(mode == 'reg')
                tmp = lapply(kws, function(kw){
                    temp = str_match(godf$Description, kw)
                    temp = !is.na(temp)
                    temp = which(temp)
                    return(temp)
                })
            else
                tmp = lapply(kws, function(kw) which(godf$Description == kw))
            tmp = Reduce(c, tmp)
            tmp = unique(tmp)
            return(tmp)
        }
        
        #Select GO term based on including and excluding key words
        if(is.null(include)) idx_in = 1:nrow(godf)
        else idx_in = query_idx(include, mode = include_mode)
        if(is.null(exclude)) idx_ex = NULL
        else idx_ex = query_idx(exclude, mode = exclude_mode)
        godf = godf[idx_in[! idx_in %in% idx_ex],]
        
        #Select cluster based on above GO sub-table and cluster informational table
        message("[INFO] Construct dataframe for ggplot...")
        message("[INFO] Remove following cluster:")
        lack.in.cinfo = setdiff(unique(godf$Cluster), cinfo$ordered.name)
        message(sprintf("       |-- Not in cinfo: %s", paste(lack.in.cinfo, collapse = ', ')))
        lack.in.godf = setdiff(cinfo$ordered.name, unique(godf$Cluster))
        message(sprintf("       |-- Not in godf: %s", paste(lack.in.godf, collapse = ', ')))
        #print(666)
        common_c = intersect(cinfo$ordered.name, unique(godf$Cluster))
        godf = godf[godf$Cluster%in%common_c,]
        cinfo = cinfo[cinfo$ordered.name%in%common_c,]
        rownames(cinfo) = 1:nrow(cinfo)
        
        #Construct dataframe for ggplot
        desc_levels = rev(unique(godf$Description))
        ggdf = data.frame(
            x.value = rownames(cinfo)[match(godf$Cluster, cinfo$ordered.name)],
            x.label = factor(godf$Cluster, cinfo$ordered.name, ordered = TRUE),
            y.value = match(godf$Description, desc_levels),
            y.label = factor(godf$Description, desc_levels, ordered = TRUE),
            point.size = godf$Count,
            point.color = -1 * log10(godf$p.adjust),
            #cluster = godf$Cluster,
            stringsAsFactors = FALSE)
        
        #Remove the top and bottom white edges of the figure
        ggdf$y.value = ggdf$y.value + 1
        top = ggdf[1,,drop=FALSE]
        bottom = ggdf[nrow(ggdf),,drop=FALSE]
        col_change = c('y.value','y.label','point.size','point.color')
        top[1,col_change] = c(1,'',NA,NA)
        bottom[1,col_change] = c(max(ggdf$y.value)+1,' ',NA,NA)
        ggdf = rbind(top, ggdf, bottom)
        ggdf$x.value = as.integer(ggdf$x.value)
        ggdf$y.value = as.integer(ggdf$y.value)
        ggdf$point.size = as.numeric(ggdf$point.size)
        ggdf$point.color = as.numeric(ggdf$point.color)
        rownames(ggdf) = 1:nrow(ggdf)
        
        return(ggdf)
    }
    make_ggdf(evego.df, include = inkw, include_mode = 'reg', cinfo = cinfo)
    
    ## Plot GO dotplot
    plotGO = function(ggdf, xy.size=c(10,10), rotate.y.label=-30){
        # size: axis text size of (x, y)
        # rotate.y.label: rotate labels of y axis
        library(ggplot2)
        p = ggplot(ggdf, aes(x = x.value, y = y.value)) +
            geom_point(aes(size = point.size, color = point.color)) +
            scale_colour_gradient(low = "blue", high = "red") + theme_bw() +
            scale_size(range = c(1, 5)) +
            labs(x = 'Cluster', y = '', title = '') +
            scale_y_continuous(
                breaks = seq(2, max(ggdf$y.value)-1), 
                labels = levels(ggdf$y.label),
                expand = c(0, 0), 
                position = 'right') +
            scale_x_continuous(
                breaks = seq(max(ggdf$x.value)),
                labels = levels(ggdf$x.label))
        
        if(rotate.y.label){
            p = p + theme(
                axis.text.x = element_text(size = xy.size[1]),
                axis.text.y = element_text(angle = rotate.y.label, vjust = 0, size = 8),
                legend.position = 'top',
                axis.ticks = element_blank())
        }
        else{
            p = p + theme(
                axis.text.x = element_text(size = xy.size[1]),
                axis.text.y = element_text(size = xy.size[2]),
                legend.position = 'top',
                axis.ticks = element_blank())
        }
        return(p)
    }
    
    ## Save GO dotplot
    saveGO = function(plot, h=12, w=8){
        
        fn = function(prefix='temp-', suffix='.pdf', time.format='YYYYMMDDHHMMSS'){
            time_str = as.character(Sys.time())
            ptn1 = paste(rep('(.*)',3),collapse='-')
            ptn2 = paste(rep('(.*)',3),collapse=':')
            pattern = paste(ptn1, ptn2)
            d = stringr::str_match(time_str, pattern)[1,2:7]
            names(d) = c('YYYY', 'MM', 'DD', 'HH', 'MM', 'SS')
            time_str = time.format
            for (key in names(d)){
                time_str = gsub(key, d[key], time_str, fixed = TRUE)
            }
            paste0(prefix, time_str, suffix)
        }
        time_str = fn("","")
        go.dir = paste0("plotGO-", time_str)
        dir.create(go.dir)
        setwd(go.dir)
        
        message("[INFO] Save ggplot object...")
        saveRDS(plot, file = "plotGO-ggplot_object.rds")
        
        message("[INFO] Save GO dotplot...")
        ggsave("plotGO-dotplot.pdf", plot = plot, height = h, width = w, limitsize = FALSE)
        fp = sprintf("../plotGO-%s.pdf", time_str)
        ggsave(fp, plot = plot, height = h, width = w, limitsize = FALSE)
        
        message("[INFO] Save GO related terms...")
        terms = data.frame(x=levels(plot$data$y.label), stringsAsFactors = FALSE)
        write.table(terms, "plotGO-all_terms.csv", row.names = F, col.names = F, quote = F)
        
        message("[INFO] Save GO data...")
        df = plot$data
        df = df[-c(order(df$y.value)[1],order(df$y.value,decreasing=T)[1]),]
        write.table(df, "plotGO-plot_data.csv", row.names = F, col.names = T, quote = F, sep = '\t')
        
        setwd("../")
    }
})


## GO plot ##
## The order of arrangement on x axis, usually equals the result of hierarchical clustering
## Used to build cluster informational table
#ordered.num = c(10,20,11,13,14,17,19,16,7,8,21,12,18,5,4,6,3,1,2,9,15)

## Annotation of target clusters prepared manually
cluster_info = readRDS("each_cluster_information.rds")

## Load csv files into dataframe list
go.dfs = load_go_files(paste0("./GO_tables"), "GO-enrich_cluster(\\d+)\\.csv")

## Check names of the list and change them if necessary
print(names(go.dfs))
names(go.dfs) = paste0('C', names(go.dfs))

## Combine all dataframe in the list into one table
go.df = merge2godf(go.dfs)

## Make data called `ggdf` for ggplot
## You can specify `include` and `include_mode` to select specific terms
## and specify `exclude` and `exclude_mode` to remove related terms from selected set
ggdf = make_ggdf(go.df, cluster_info, include = 'T cell')

## Plot GO dotplot
## You can set `rotate.y.label` to rotate y-axis labels, advised 0 or -30
p = plotGO(ggdf, "Cluster", rotate.y.label = 0)


## You may fine tune `h` and `w` of saveGO function to fit actual size of ggdf data
saveGO(p, h=8, w=10)
